---
author: Савченко Елизавета Николаевна
subtitle: "Дисциплина: Математические основы защиты информации и
  информационной безопасности"
title: "Отчёт по лабораторной работе №1: Шифры простой замены"
---

# Содержание {#содержание .TOC-Heading}

[1 Общая информация о задании лабораторной работы
[3](#общая-информация-о-задании-лабораторной-работы)](#общая-информация-о-задании-лабораторной-работы)

[1.1 Цель работы [3](#цель-работы)](#цель-работы)

[1.2 Задание \[1\] [3](#задание-1)](#задание-1)

[2 Теоретическое введение \[2\]
[3](#теоретическое-введение-2)](#теоретическое-введение-2)

[2.1 Шифры и симметричные шифры
[3](#шифры-и-симметричные-шифры)](#шифры-и-симметричные-шифры)

[2.2 Шифры простой замены
[3](#шифры-простой-замены)](#шифры-простой-замены)

[2.2.1 Моноалфавитные шифры
[3](#моноалфавитные-шифры)](#моноалфавитные-шифры)

[2.2.2 Шифр Атбаш [4](#шифр-атбаш)](#шифр-атбаш)

[3 Выполнение лабораторной работы \[1\]
[5](#выполнение-лабораторной-работы-1)](#выполнение-лабораторной-работы-1)

[3.1 1. Реализация шифра Цезаря для произвольного ключа $k$
[5](#реализация-шифра-цезаря-для-произвольного-ключа-mathbfk)](#реализация-шифра-цезаря-для-произвольного-ключа-mathbfk)

[3.2 2. Реализация шифра Атбаш
[6](#реализация-шифра-атбаш)](#реализация-шифра-атбаш)

[4 Выводы [8](#_Toc209892372)](#_Toc209892372)

[Список литературы [9](#список-литературы)](#список-литературы)

# 1 Общая информация о задании лабораторной работы

## 1.1 Цель работы

Ознакомиться с классическими примерами шифров простой замены.

## 1.2 Задание \[1\]

1.  Реализовать шифр Цезаря с произвольным ключом $k$;
2.  Реализовать шифр Атбаш.

# 2 Теоретическое введение \[2\]

## 2.1 Шифры и симметричные шифры

Первоначальное сообщение от одного пользователя к другому названо
исходным текстом; сообщение, передаваемое через канал, названо
зашифрованным текстом. Чтобы создать зашифрованный текст из исходного
текста, отправитель использует алгоритм шифрования и совместный ключ
засекречивания. Для того чтобы создать обычный текст из зашифрованного
текста, получатель использует алгоритм дешифрования и тот же секретный
ключ. Мы будем называть совместное действие алгоритмов шифрования и
дешифрования шифровкой. Ключ --- набор значений (чисел), которыми
оперируют алгоритмы шифрования и дешифрования.

Обратите внимание, что шифрование симметричными ключами использует
единственный ключ (ключ, содержащий непосредственно набор кодируемых
значений) и для кодирования и для дешифрования. Кроме того, алгоритмы
шифрования и дешифрования --- инверсии друг друга. Если $P$ --- обычный
текст, $C$ --- зашифрованный текст, а $K$ --- ключ, алгоритм кодирования
$E_{k}(x)$ создает зашифрованный текст из исходного текста.

Алгоритм же дешифрования Dk (x) создает исходный текст из зашифрованного
текста. Мы предполагаем, что $E_{k}(x)$ и $D_{k}(x)$ обратны друг другу.
Они применяются, последовательно преобразуя информацию из одного вида в
другой и обратно.

## 2.2 Шифры простой замены

Мы можем разделить традиционные шифры с симметричным ключом на две
обширные категории: шифры подстановки и шифры перестановки. В шифре
подстановки мы заменяем один символ в зашифрованном тексте на другой
символ; в шифре перестановки --- меняем местами позиции символов в
исходном тексте.

Шифры простой замены относятся к шифрам подстановки.

### 2.2.1 Моноалфавитные шифры

Сначала обсудим шифры подстановки, называемые моноалфавитными шифрами. В
такой подстановке буква (или символ) в исходном тексте всегда изменяется
на одну и ту же самую букву (или символ) в зашифрованном тексте
независимо от его позиции в тексте. Например, если алгоритм определяет,
что буква A в исходном тексте меняется на букву D, то при этом каждая
буква A изменяется на букву D. Другими словами, буквы в исходном тексте
и зашифрованном тексте находятся в отношении один к одному.

В моноалфавитной подстановке отношения между буквой в исходном тексте и
буквой в зашифрованном тексте --- один к одному.

#### 2.2.1.1 Аддитивные шифры

Самый простой моноалфавитный шифр --- аддитивный шифр, его иногда
называют шифром сдвига, а иногда --- шифром Цезаря, но термин аддитивный
шифр лучше показывает его математический смысл. Предположим, что
исходный текст состоит из маленьких букв (от a до z) и зашифрованный
текст состоит из заглавных букв (от A до Z). Чтобы обеспечить применение
математических операций к исходному и зашифрованному текстам, мы
присвоим каждой букве числовое значение (для нижнего и верхнего
регистра).

Каждому символу (нижний регистр или верхний регистр) сопоставлено целое
число из кольца $Z_{26}$. Ключ засекречивания между отправителем и
получателем --- также целое число в кольце $Z_{n}$. Алгоритм кодирования
прибавляет ключ к символу исходного текста; алгоритм дешифрования
вычитает ключ из символа зашифрованного текста. Все операции проводятся
в кольце $Z_{n}$.

##### 2.2.1.1.1 Шифр сдвига

Исторически аддитивные шифры назывались шифрами сдвига --- по той
причине, что алгоритм шифрования может интерпретироваться как "клавиша
сдвига буквы вниз", а алгоритм дешифрования может интерпретироваться как
"клавиши сдвига буквы вверх". Например, если ключ = 15, алгоритм
кодирования сдвигает букву на 15 букв вниз (к концу алфавита). Алгоритм
дешифрования сдвигает букву на 15 букв вверх (к началу алфавита).
Конечно, когда мы достигаем конца или начала алфавита, мы двигаемся по
кольцу к началу (объявленные свойства операции по модулю 26).

##### 2.2.1.1.2 Шифр Цезаря

Юлий Цезарь использовал аддитивный шифр, чтобы связаться со своими
чиновниками. По этой причине аддитивные шифры упоминаются иногда как
шифры Цезаря. Цезарь для своей связи использовал цифру 3.

### 2.2.2 Шифр Атбаш

Шифр Атбаш также является моноалфавитным шифром, однако отличается от
шифра Цезаря. Принцип его работы основан на том, что для шифровки
сообщения необходимо зеркально отразить алфавит, использующийся при
написании этого сообщения. Таким образом, шифр перемещает между собой
все символы алфавита (или почти все в алфавитах с нечётным числом
символом).

# 3 Выполнение лабораторной работы \[1\]

## 3.1 1. Реализация шифра Цезаря для произвольного ключа $\mathbf{k}$

Для реализации шифра Цезаря необходимо было ограничить алфавит. В тексте
лабораторной работы \[1\] предложен пример использования исключительно
латиницы. В своей реализации я предлагаю использовать в качестве
алфавита все символы ASCII, которые доступны в `Julia` \[3\].

В языке `Julia` число ASCII символов ограничено $128$ \[4\], в связи с
чем при реализации использовалась формула `mod(Int(symbol)+k, 128)` для
преобразования каждого символа `symbol`, где $k$ -- смещение, задаваемое
в качестве параметра функции.

`julia``> function ``Сesar_``cipher``(``text::String, k::Int)`

`           result = ``IOBuffer``(``)`

`               for ``ch`` in text`

`               if`` 'А' <= ``ch`` <= 'Я``'  #`` Заглавные русские буквы`

`                   ``shifted = Char(``mod(``Int(``ch``) - Int('А') + k, 32) + Int('А'))                               print(result, shifted)`

`                                       elseif`` 'а' <= ``ch`` <= 'я``'  #`` Строчные русские буквы`

`                   ``shifted = Char(``mod(``Int(``ch``) - Int('а') + k, 32) + Int('а'))                               print(result, shifted)`

`                                       else`

`                   # Все другие символы без изменений`

`                               ``print(``result, ch)`

`               end`

`           end`

`julia``> ``println``(``caesar_cipher``("``Молодец``!", 2))`

`Орнржзш``!`

При проверке правильности реализации важно учитывать, что шифры простой
замены (а, значит, и шифр Цезаря) относятся к симметричным шифрам. Шифр
Цезаря симметричен относительно размера своего алфавита: для расшифровки
сообщений необходимо использовать индентичный алфавит, однако при
расшифровке необходимо использовать значение параметра
$k_{decoder} = alphabet\, length\mspace{6mu} - \mspace{6mu} k_{encoder}$.
Это важно при проверке правильности работы шифра, для чего изначальное
сообщение мы пропускаем дважды через функцию, которая зашифровывает
сообщение. Так мы должны получить шифрокод после первого запуска
функции, и изначальное сообщение после второго запуска функции

    coded_text = shifrCezarya(3, "TEXT to be coded!!!! αβγ and some innocent letters")
    println("The result of encoding:\n", coded_text, "\n\n")
    decoded_text = shifrCezarya(-131, coded_text)
    println("The result of decoding:\n", decoded_text)

Результат работы кода представлен ниже (рис. 1).

![](C:/Users/eliza/PycharmProjects/5G/informationsecurity/media/image1.png){width="6.728472222222222in"
height="1.5979166666666667in"}

Рис. 1: Результат работы шифра Цезаря

## 3.2 2. Реализация шифра Атбаш

Для реализации шифра Атбаш необходимо было ограничить алфавит. В тексте
лабораторной работы \[1\] предложен пример на языке `Pascal`, в котором
алфавит символов ограничен 256 символами ASCII.

В языке `Julia` число ASCII символов ограничено $128$ \[4\], в связи с
чем при реализации использовалась формула `127-Int(symbol)` для
преобразования каждого символа `symbol`.

`julia``> function ``atbash_``cipher``(``text::String, k::Int=0)`

`           ``# В ``атбаш`` обычный ключ не используется, это фиксированное отражение`

`               # Но если нужен ключ ``k`` — реализуем модифицированный ``атбаш``:`

`           # сначала отражаем буквы, затем сдвигаем результат на ``k`

`           ``function ``reflect_russian``(``ch``)`

`                   if 'А' <= ``ch`` <= 'Я'`

`                   return ``Char(``Int('А') + (Int('Я') - Int(``ch``)))`

`                           elseif 'а' <= ``ch`` <= 'я'`

`                   return ``Char(``Int('а') + (Int('я') - Int(``ch``)))`

`                           else`

`                   return ``ch`

`               end`

`           end`

`           function ``shift_``russian``(``ch``, k)`

`               if 'А' <= ``ch`` <= 'Я'`

`                   return Char(``mod(``Int(``ch``) - Int('А') + k, 32) + Int('А'))`

`                           elseif 'а' <= ``ch`` <= 'я'`

`                   return Char(``mod(``Int(``ch``) - Int('а') + k, 32) + Int('а'))`

`                           else`

`                   return ``ch`

`               end`

`           end`

Для ограничения числа символов, с которыми ведётся работа, до алфавита
из $128$ ASCII символов, реализованных в Julia, на вводимый текст перед
зашифровкой применяется фильтр, который пропускает исключительно символы
ASCII и отбрасывает посторонние символы. После этого дополнительно
пользователю демонстрируется фраза, которая получилась после фильтрации
посторонних символов.

При проверке правильности реализации важно учитывать, что шифры простой
замены (а, значит, и шифр Атбаш) относятся к симметричным шифрам. Причём
шифр Атбаш, в отличие от уже разобранного шифра Цезаря, симметричен
только с учётом идентичности алфавита при шифровании и дешифровании. Это
важно при проверке правильности работы шифра, для чего изначальное
сообщение мы пропускаем дважды через функцию, которая зашифровывает
сообщение. Так мы должны получить шифрокод после первого запуска
функции, и изначальное сообщение после второго запуска функции.

`                   result = ``IOBuffer``(``)`

`                       for ``ch`` in text`

`               reflected = ``reflect_russian``(``ch``)`

`                       shifted = ``shift_``russian``(``reflected, k)`

`               ``print(``result, shifted)`

`                   end`

`                       return String(``take!(``result))`

`                       end`

`atbash_cipher`` (generic function with 2 methods)`

`julia``> ``println``(``atbash_cipher``("``Молодец``!", 2))`

`Хуцуэьл``!`

`julia``>`

Результат работы кода представлен ниже (рис. 2).

![](C:/Users/eliza/PycharmProjects/5G/informationsecurity/media/image2.png){width="6.728472222222222in"
height="6.123611111111111in"}

Рис. 2: Результат работы шифра Атбаш

# 4 Выводы {#выводы-1}

В результате работы мы ознакомились с традиционными моноалфавитными
шрифтами простой замены, а именно:

-   Шифром Цезаря;
-   Шифром Атбаш.

Также были записаны скринкасты:

-   [Выполнения лабораторной
    работы](https://rutube.ru/video/ec91c9ff836f7967482d5b272fe9bf58/)
-   [Запись создания
    отчёта](https://rutube.ru/video/5de97e1e76e764109d0181b30dd1cd34/)
-   [Запись создания
    презентации](https://rutube.ru/video/9dfb50ad9a435334fb9b75475dc50750/)
-   [Защита лабораторной
    работы](https://rutube.ru/video/7471ffd5c324c3c5ed3a431570f5aada/)

# Список литературы

1\. Лабораторная работа №1. Шифры простой замены \[Электронный ресурс\].
RUDN, 2024. URL:
<https://esystem.rudn.ru/pluginfile.php/2368506/mod_folder/content/0/lab01.pdf>.

2\. Математика криптографии и теория шифрования \[Электронный ресурс\].
URL: <https://intuit.ru/studies/courses/552/408/info>.

3\. Julia 1.10 Documentation \[Электронный ресурс\]. 2024. URL:
<https://docs.julialang.org/en/v1/>.

4\. Julia 1.10 Documentation \[Электронный ресурс\]. 2024. URL:
<https://docs.julialang.org/en/v1/base/strings/>.
